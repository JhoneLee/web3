# ethers.js 汇总

## 1. 基本概念

### 1.1 provider

> provider 是最基础的对象，允许查询区块链状态，例如账户、区块或交易细节，查询事件日志或通过调用评估只读代码：

#### 初始化

初始化分为三种情况，一种是用户安装了 MetaMask, 可以派生出 signer 对象

```js
provider = new ethers.BrowserProvider(window.ethereum);
```

另一种用户没装，给一个默认的, 默认的无法提供 signer

```javascript
provider = ethers.getDefaultProvider();
```

还有一种是连接第三方的 JsonRpc 服务，可以派生 signer

```javascript
provider = new ethers.JsonRpcProvider("YOUR_INFURA_URL");
```

##### 主要功能划分

- 区块链信息: 只读一些区块链公开的信息，包括但不限于以下常用：
  - getBlockNumber() 最新区块号
  ```javascript
  await provider.getBlockNumber(); // 23
  ```
  - getBlock(blockNumber|"latest") 该区块号信息，继承自区块类
- [账户信息](https://learnblockchain.cn/ethers_v5/api/providers/provider/#Provider--account-methods)
  - getBalance(address) 查看这个地址的以太币余额
- 交易信息
  - getTransaction(tradeHash) 获取交易哈希中的交易详情
  - getTransactionReceipt(tradeHash) 获取此交易哈希中的交易收据
  - estimateGas(transaction) 估算执行交易需要的 gas 费
    - transaction 参数： to: 目标地址 data: 传递的数据
  - getGasPrice() ： 获取当前网络的 gas 价格 单位 wei
- 网络信息： 包括查询当前网络，
  - getNetwork() ： 获取当前连接的以太坊网络的相关信息

#### 1.3.2 signer

> signer 封装了所有与账户交互的操作。一个账户通常包含一个私钥，用于签署各种类型的数据。：

##### 派生方式

```javascript
let signer = new ethers.Wallet("YOUR_PRIVATE_KEY", provider);

signer = await provider.getSigner();
```

私钥保护是个问题

#### 1.3.3 transaction

> 要使区块链状态改变，就要发起一笔交易，并支付交易费用
> 部署合约是交易，调用合约非 view/pure 方法也会有交易

#### 1.3.4 contract

> 智能合约的具象化，和智能合约交互的对象

- 只调只读函数的合约对象： `new ethers.Contract(contractAddress, contractABI, provider);` 第三个参数是 provider
- 可调读写函数的合约对象： `new ethers.Contract(contarctAddress, abi, wallet);` 第三个参数为 钱包对象

## 2 数据对象

- Fragment : 描述函数/事件的结构
- interface: 合约接口
- abi: 是 js 和 evm 交互的中间数据结构，可以通过合约对象的 interface 对象生成，每个合约生成 abi 编码只能给自己用，不能传递给其他合约
- bytecode：主要指 evm 字节码，是 solidity 编译后的产物。 用户签名信息不是字节码。

## 3 基本概念

### 3.1 区块分支

在区块链中，"分支"（branch）通常指的是区块链的一个分支路径，也就是说，区块链的历史记录中出现了不同的版本或路径。在区块链的运作中，分支通常发生在以下几种情形：

3.1.1 **硬分叉（Hard Fork）**：
硬分叉是区块链协议规则的重大变化，它导致旧的区块链和新的区块链之间的兼容性丧失。硬分叉可能会导致区块链分裂成两个不同的链，每个链遵循不同的协议规则。例如，比特币和比特币现金（BCH）就曾发生过硬分叉，导致了两个独立的区块链。
在硬分叉发生后，之前的版本和新的版本将完全分离，两者之间并没有交流或交易选项。通常，新版本继承了老版本的历史交易，而每个版本将会拥有自己的交易历史。

3.1.2 **软分叉（Soft Fork）**：
软分叉是协议规则的向后兼容性更新，即新规则和旧规则能够兼容。虽然网络上有不同的节点执行不同的规则，但整体区块链仍然保持在同一条链上。软分叉通常不会导致区块链的分裂，只会导致某些节点不再验证符合新规则的交易或区块。

3.1.3 **临时分支**：
在区块链的正常运作中，当不同的矿工（或验证者）同时挖出或验证了相同高度的区块时，网络可能会暂时出现多个分支。最终，网络会通过一个机制（如工作量证明或权益证明）来选择其中一个链作为“主链”，其他链则会被废弃。例如，比特币的分叉在区块链的正常运行中是暂时的，当网络达成共识后，会只保留最长的链。

**分支的概念**对于区块链的去中心化和容错性至关重要。在网络中分支允许区块链在面对故障、攻击或者升级时保持弹性，但也会引发不同的经济激励问题和社区分歧。

ethers.js 里面提到的分支就是临时分支

### 3.2 区块重组

如果矿工在链上发现了不同的临时分支，可能会丢弃一部分已挖掘的区块并重新组织区块链。

### 3.3 交易替代

当一笔交易在网络中未及时被挖掘时，用户可能会通过相同的 nonce 发起另一笔交易，这样新的交易可能会替代原有的交易。

### 3.4 事件重新排序

在以太坊等区块链上，由于网络的不可预测性，交易的顺序和区块的组织可能会发生变化。交易替代和区块重组会导致事件重新排序

### 3.5 孤立事件

孤立事件是指那些原本会在某个区块内触发的事件，单由于发生事件重新排序，它们变得不再有效或被排除在当前链外。通过 TransactionResponse 对象的 reorderedEvent，开发者可以监听和处理这些事件，确保他们能够及时响应交易执行的变动。

### 3.6 费用相关

智能合约发生计算需要消耗 gas，这里的 gas 是计量单位，用户还需要给这个单位报价，1 个 gas 多少 wei 的以太币才能完成交易

- Gas 是一种计量单位，用于衡量执行交易或智能合约所需的计算工作量。
- Gas Price（Gas 价格） 是用户愿意为每单位 Gas 支付的价格，通常以以太坊（ETH）表示。
- Gas Limit（Gas 限额） 是用户愿意为一笔交易支付的最大 Gas 数量。

交易费用 = Gas 数量（Gas Used）× Gas 价格
用户可以通过设置 Gas 价格和 Gas 限额来控制他们愿意支付的最大费用。
矿工会优先处理那些 Gas 价格较高的交易，因为他们从中获得的奖励更多

### 3.7 链分叉

区块链在交易确认的过程中，矿工有时会几乎在相同的时间挖出新的区块，并广播到网络中。这会导致一时之间网络节点看到不同的区块链分支。

但是链最终还是要保持一致的，对于这种多出来的分支，区块链自身不会搞 git 那种代码合并的处理方式去处理分支链，而是等待哪个分支被大多数矿工所认可，最终将区块数量最多的链作为 确认链 合入自己的“主干”， 其余的链分支都丢弃

这样就导致某些确认数不够的交易被丢弃，引发双重支付攻击

### 3.8 双重支付攻击

所谓双重支付攻击就是 A 想要买 B 的商品，A 给 B 转账后 B 那边显示金额到账，B 然后发货，可是 A 又发起了另一笔转账，转给了自己另一个账户 C，造成了链发生了分叉。

然后攻击者 A 通过自己控制一定的算力增加 AC 交易的确认数，导致 AB 交易的分叉被抛弃，使得 B 在过一段时间之后并没有收到钱，最终上当受骗；

攻击者 A 账户要有足够的金额能支持同时发起两笔转账，同时还要有一定的算力，能够引导真实转账分叉被抛弃；

### 3.9 节点

在以太坊网络中，节点指的是网络中的每一个计算机或设备，这些节点共同参与以太坊区块链的维护和运行。节点的职责包括验证交易、存储区块链的状态、广播交易以及执行智能合约等操作。

任何人任何组织的计算机只要安装了以太坊的客户端，即可将自己的计算机纳入到以太坊的网络里，成为一个节点，根据安装的客户端种类不同，决定自己是什么节点类型；

节点分类：

- 全节点：保存了区块链的完整数据（包括区块头和交易），并且验证所有区块和交易的有效性
  - 存储区块链数据
  - 验证交易
  - 参与共识
- 轻节点： 资源要求最低的节点类型，适合需要低存储和带宽的环境（如移动设备）。它只存储区块头信息，并依赖全节点来获取详细数据。
- 存档节点：存档节点是资源要求最高的节点类型，适合需要完整历史数据和状态的应用。它存储整个区块链的完整状态，并支持查询任意时间点的区块链数据。

### 3.10 确认数

当我的交易被广播到链上的时候，矿工/验证者会将我的交易和其他交易打包成一个区块，这个区块会基于当前的链做成一个链分叉，如果当前的链分叉被后续的矿工采纳并基于此进行之后区块的打包，那么我的交易确认数会逐渐增加，理论上当确认数大于等于 6 的时候说明这个交易稳了；

### 3.11 区块

> 区块由区块头和区块体组成， 区块链的大部分功能都由区块头实现， 区块主体负责记录前一段时间内的所有交易信息

#### 区块头

- 版本号(Version)：表示当前区块的版本号，用于标识当前区块所使用的协议和规范
- 父区块哈希值(Previous Block Hash)：表示当前区块之前一个区块的哈希值，这样就形成了区块链的不可篡改性
- Merkle 根(Merkle Root)：表示当前区块中所有交易信息的 Merkle 树根哈希值，用于保证区块中交易信息的完整性
- 时间戳(Timestamp)：表示当前区块的时间戳，用于记录区块的产生时间
- 难度目标(Difficulty Target)：表示当前区块的哈希值必须满足的难度目标，这个值是根据当前网络计算出来的，用于保证区块链的安全性和可靠性
- 随机数(Nonce)：用于计算区块哈希值的随机数，通过不断尝试不同的随机数以满足难度目标为目的，从而保证区块的唯一性和完整性

#### 区块体

- 交易记录(Transactions)：表示当前区块中包含的交易信息，每个交易都包含了交易双方的地址、交易金额、交易时间等信息
- 交易计数器(Transaction Counter)：表示当前区块中包含的交易数量，用于区分不同的区块

#### 图示

```javascript
+-------------------------------------------------------+
|                                                       |
|           +----------------------+                    |
|           | Block Header         |                    |
|           +----------------------+                    |
|           | Version              |                    |
|           | Previous Block Hash  |                    |
|           | Merkle Root          |                    |
|           | Timestamp            |                    |
|           | Difficulty Target    |                    |
|           | Nonce                |                    |
|           +----------------------+                    |
|                                                       |
|           +----------------------+                    |
|           | Transactions         |                    |
|           +----------------------+                    |
|           | Transaction 1        |                    |
|           | Transaction 2        |                    |
|           | Transaction 3        |                    |
|           | ...                  |                    |
|           +----------------------+                    |
|                                                       |
|                                                       |
|           +----------------------+                    |
|           | Block Hash           |                    |
|           +----------------------+                    |
|                                                       |
+-------------------------------------------------------+
```

### 3.12 以太坊分层

- 存储层：用于存储以太坊系统运行过程中产生的区块链元数据和系统日志。区块链元数据采用 LevelDB 数据库存储，系统日志由文件系统存储。
- 数据层：数据层是区块链的核心，主要处理以太坊交易中的各类数据，完成数据的编码、解码，将数据打包成区块，将区块拼接成链式结构，处理区块数据签名并添加时间戳印记，将交易数据构建成 Merkle 树，并计算 Merkle 树根节点的 hash 值等。
- 网络层：主要实现网络节点的连接和通讯，又称点对点技术（P2P）。
- 协议层：以太坊提供的供系统各模块相互调用的协议。
- 共识层：制定区块链的获取货币的机制。比如比特币用的是 POW（Proof of Work 工作量证明机制）：电脑的性能越好，越容易获取到货币奖励。还有 POS（Proof of Stake 权益证明机制）：类似于众筹分红的概念，会根据你持有的货币数量和时间，给持有者发放利息。还有比如超级账本用的是 PBFT（拜赞庭容错）。
- 激励层：挖矿机制。
- 合约层：以往的区块链是没有这一层的。所以最初的区块链只能进行交易，而无法用于其他的领域或是进行其他的逻辑处理。但是合约层的出现，使得在其他领域使用区块链成为了现实，比如用于 IOT。以太坊中这部分包括了 EVM（以太坊虚拟机）和智能合约两部分。
- 应用层：区块链的展示层。如以太坊使用的是 truffle 和 web3-js。区块链的应用层可以是移动端，web 端，或是是融合进现有的服务器，把当前的业务服务器当成应用层。

### 3.13 信标链

是部署在共识层的一个独立的链，不像传统区块链那样依赖于每个区块链上的交易。它主要负责管理网络的 共识 和 验证者，而不是直接处理用户的交易或智能合约

信标链里的区块叫信标区块，这些区块和执行层区块链（负责执行智能合约、矿工打包部署新区块的链）一一对应，只有对应了信标区块的执行层区块，里面的交易才被认为是交易已经确认不可撤销、丢失的交易

### 3.14 交易回执树

是一颗默克尔树
记录如下信息

- 事务的成功与否（是否被成功执行）
- 日志事件（例如合约事件的日志）
- Gas 消耗（交易执行过程中消耗的 Gas）
- ContractAddress（如果是合约部署交易，合约的地址）

### 3.15 全局状态树

所有账户的状态（包括账户余额、智能合约存储等）是通过一个 Merkle Patricia Trie（默克尔 Patricia 树）来存储和管理的。这棵树的根哈希称为 stateRoot。

- 账户状态：每个以太坊账户（外部账户或合约账户）有一组关联的数据，包括余额、nonce、合约存储等。
- 智能合约的存储：智能合约会有自己的存储空间，这个存储也是通过 Trie 结构来管理的。
- 全局状态：整个以太坊网络的所有账户和合约的状态数据，都存储在一个巨大的 Merkle Patricia Trie 中，stateRoot 就是这个 Trie 树的根哈希。

### 3.16 存储槽

在以太坊的智能合约中，存储槽是合约中用于存储**状态变量**的固定位置。每个合约的状态变量都会被分配到一个存储槽（位置），并以顺序存储。

- 事件不占用存储槽
- 函数不占用存储槽

### 3.17 CCIP

> 跨链互操作协议

是一个旨在简化不同区块链之间互操作性的协议，使得不同的区块链可以更方便地进行信息和资产的交换，从而打破了不同链之间的“孤岛”问题。 比如让以太坊可以和币安交易。

- 跨链互操作性： CCIP 允许不同的区块链网络（如 Ethereum, Solana, Avalanche 等）之间相互通信、传递数据和转移资产。这样，无论资产在哪个区块链上，都能在其他链上进行使用。

- 资产转移： CCIP 使得用户或应用可以将资产从一个链转移到另一个链，而无需依赖中心化的交易所或复杂的桥接协议。通过统一的协议，跨链交易变得更加简单和安全。

- 智能合约调用： 除了转移资产，CCIP 还支持跨链智能合约调用。也就是说，一个链上的智能合约可以调用另一个链上的合约，这为跨链的去中心化应用（DApp）提供了更多可能。

- 去中心化和安全性： CCIP 是去中心化的，不依赖单一的中心化服务。这意味着它能够避免单点故障的问题，提高了跨链操作的安全性。

### 3.18 秘钥

助记词 -> 种子 -> 私钥 -> 公钥 -> 钱包地址
基础概念

- **助记词**： 是恢复加密钱包所需全部信息的一系列英文词汇， 由 12 15 18 或 24 个单词组成，是从一个固定的 2048 长度的单词列表中产生的 相当于银行卡密码 **BIP-39**
- **种子**： 助记词 + salt -- SHA512 算法 --> 一段 512 位（8 位一个字节，共 64 字节）hash 值（用十六进制表示这 512 位） 就是种子
- **私钥** ： 可以有很多个，完全由种子推导出的(**BIP-32**) ，推导的规则需要 BIP-44 约束，规定私钥的组成由币种、链类别等信息表示，让多个私钥更有层次感
- **公钥** ： 通过私钥用椭圆曲线数字签名算法计算出来的
- **钱包地址** ：对公钥进行 hash 计算，得出钱包地址

加密消息验证过程（抽象版）
打个比方，假设我有一个公式生成签名消息， 私钥是 5， 公钥是 10， 我用私钥签名对不同的消息得出 100 200 110 等等 10 的整数倍数字，然后验证方拿到公钥和签名的消息后，有这么一个判断 消息是 10(公钥)的整数倍 这么评判公式， 就说明消息是私钥发过来的，如果遇到 55 16 89 这些消息就不是。

### 3.19 JSON Wallet

是一种用于存储以太坊私钥的格式，它将私钥和相关信息以 JSON 格式存储，并允许使用不同的加密方法进行保护。JSON 钱包格式提供了一种简洁、安全的方式来存储和管理私钥，广泛用于以太坊及其他区块链应用中。

- 存储私钥：JSON 钱包主要用于存储私钥，而私钥是控制以太坊账户和进行交易的关键。除了私钥外，还会存储一些与账户相关的元数据，比如加密算法的配置、生成私钥时使用的盐（salt）等。

- 可扩展的加密方式：JSON 钱包支持多种加密算法。最常见的是使用密码对私钥进行加密，确保即使钱包文件被获取，未经授权的人也无法访问其中的私钥。

- 易于解密和加密：提供了工具和方法来轻松地对 JSON 钱包进行加密和解密。用户可以通过输入正确的密码来解密钱包，从而获得私钥并使用它进行交易等操作。

### 3.20 位数换算

凡是后面标数字的都表示这个数据占多少位
比如 keccak256 就是 256 位， 1 个位就表示 1 个二进制数据
8 位表示 1 个字节，keccak256 就是产生一个 32 字节的数据
在 ethers 世界里，哈希数据都用 16 进制表示， 4 个二进制转为 1 个十六进制数字， 所以 keccak256 产生结果就是一个长度位 64 的十六进制字符串， 也就是 256/4

## 4 算法概念

### 4.1 布隆过滤器：

是一种 概率数据结构，用来测试一个元素是否在集合中。它具有 快速查询 和 内存高效 的特点，但存在一定的误判率，即它可能错误地返回某个元素存在，但绝不会误判元素不存在。

在以太坊中，布隆过滤器用来优化查询日志的效率，避免了需要遍历整个日志链表的性能瓶颈。

由于 布隆过滤器 是一个固定大小的位图，它能有效地判断某些日志是否出现在某笔交易中，而不需要完全扫描所有日志。

## 5 总结

### 5.1 发送交易

- 直接调智能合约的方法
- contractRunner.sendTransaction 前提是这个 runner 的函数支持交易
- wallet.sendTransaction

### 5.2 事件筛选

- filter ： contract.filters['someEventName'] 主要用于从日志中筛选特定的事件， [具体使用方法](https://github.com/WTFAcademy/WTF-Ethers/tree/main/09_EventFilter#%E6%9E%84%E5%BB%BA%E8%BF%87%E6%BB%A4%E5%99%A8)
- topic: 是事件日志的一部分，**事件哈希和 indexed 变量存储在 topics 中，作为索引方便以后搜索；没有 indexed 变量存储在 data 中**。实际业务开发用不到，有 filter 就够了 它帮助定义了事件的 标识符 和 参数。每个 Topic 都是一个特定的 条件，你可以根据它来过滤事件, 可以通过 Log 类或 EventFilter 类获取 topic 列表。 每个智能合约的 topics 组成部分如下：
  - 事件签名哈希
  - 第一个 index 标识（在智能合约声明事件时，会给参数设置 indexed 修饰，最多三个） 索引 1 如果有的话
  - 第二个 index 标识 索引 2 如果有的话
  - 第三个 index 标识 索引 3 如果有的话

# ethers.js 技巧

## 1. 基本使用

### 1.1 数据格式转变

`ethers.js` 提供了一些常用的功能来转换不同单位的数字。

- **将 ETH 转换为 wei**（最小单位）：

  ```javascript
  ethers.parseEther(value.toString());
  ```

- **将 wei 转换为 ETH**：
  ```javascript
  ethers.formatEther(value.toString());
  ```

### 1.2 合约相关

#### 1.2.1 合约实例对象

- **获取合约地址**：

  ```javascript
  const address = await contract.getAddress();
  ```

- **连接到合约（绑定 signer）**：
  `connect(signer)` 方法用来将合约与一个 `signer`（即钱包）关联，之后通过该 `signer` 调用合约方法时，合约的 `msg.sender` 就是该钱包的地址。
  ```javascript
  const contractWithSigner = contract.connect(signer);
  ```

### 1.3 各种对象

#### 1.3.1 `provider`

`provider` 是用于读取区块链状态的对象，例如获取账户、交易、区块信息等。它不包含签名信息，所以不能发送交易。

##### 初始化 `provider`

1. **用户安装了 MetaMask**（使用 `window.ethereum` 提供的 provider）：

   ```javascript
   provider = new ethers.BrowserProvider(window.ethereum);
   ```

2. **默认 provider**（无法提供 signer）：

   ```javascript
   provider = ethers.getDefaultProvider();
   ```

3. **连接到第三方的 JSON-RPC 服务**（例如 Infura）：
   ```javascript
   provider = new ethers.JsonRpcProvider("YOUR_INFURA_URL");
   ```

##### 主要功能划分

- **查询区块链信息**：

  - 获取最新区块号：`provider.getBlockNumber()`
  - 获取特定区块信息：`provider.getBlock(blockNumber || "latest")`

- **查询账户信息**：

  - 查看地址余额：`provider.getBalance(address)`

- **查询交易信息**：

  - 获取交易详情：`provider.getTransaction(txHash)`
  - 获取交易收据：`provider.getTransactionReceipt(txHash)`
  - 估算 gas：`provider.estimateGas(transaction)`
  - 获取当前 gas 价格：`provider.getGasPrice()`

- **查询网络信息**：
  - 获取当前网络信息：`provider.getNetwork()`

#### 1.3.2 `signer`

`signer` 封装了与账户交互的操作，通常用于签署交易或消息。签名账户通常包含私钥。

##### 派生方式

- 通过私钥创建一个 `signer`：

  ```javascript
  let signer = new ethers.Wallet("YOUR_PRIVATE_KEY", provider);
  ```

- 从 `provider` 获取默认的 signer（通常是连接的用户账户）：
  ```javascript
  signer = await provider.getSigner();
  ```

##### 私钥保护

为了安全，私钥应通过环境变量或安全存储，而不是直接写入代码中。

#### 1.3.3 `transaction`

交易是改变区块链状态的操作，通常包括发送一些 ETH 或调用合约函数，需要支付 gas 费用。

#### 1.3.4 `contract`

`contract` 对象允许与智能合约进行交互。

- **只读合约**（无需发送交易）：

  ```javascript
  const contract = new ethers.Contract(contractAddress, contractABI, provider);
  ```

- **读写合约**（需要发送交易，传入钱包对象）：
  ```javascript
  const contract = new ethers.Contract(contractAddress, contractABI, wallet);
  ```

---

## 2. Hardhat 使用

### 2.1 单元测试

在 Hardhat 中，`ethers` 被用作智能合约的交互库，可以进行合约部署、交易发送等操作。

#### 2.1.1 获取测试账户

使用 `getSigners()` 方法可以获取一些预设的测试账户，通常包括一个 `owner` 账户和多个用户账户。

```javascript
[owner, user1, user2] = await ethers.getSigners();
```

### 2.2 合约相关

#### 2.2.1 部署合约

- **简化的合约部署**（`ethers.deployContract`）：

  ```javascript
  const counter = await ethers.deployContract('Counter', [param1, param2, ...]); // 合约初始化参数
  ```

- **标准合约部署**（使用合约工厂）：
  ```javascript
  // 获取合约工厂
  const Counter = await ethers.getContractFactory('Counter');
  // 部署合约
  const counter = await Counter.deploy(param1, param2, ...);
  await counter.waitForDeployment();
  ```
